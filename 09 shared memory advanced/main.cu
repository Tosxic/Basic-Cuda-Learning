#include <cstdio>
#include <cuda_runtime.h>
#include <vector>
#include "helper_cuda.h"
#include "CudaAllocator.h"
#include "ticktock.h"


// block中线程过多会导致寄存器打翻（register spill）
// block中所有线程共用一个寄存器仓库（register file）
// 如果block中线程数量过多，则每个线程分配到的寄存器数量减少
// 而假如程序用了大量寄存器无法存储在寄存器仓库中，就会被打翻到一级缓存，变低效
// 如果一级缓存还装不下，就会打翻到二级缓存
// 假如线程局部分配数组并通过动态下标访问，无论如何都会打翻到一级缓存，因为寄存器无法动态寻址
// 在fermi架构下，每个线程最多有63个寄存器（每个4字节）

// block中线程数量太少，会导致延迟隐藏（latency hiding）失效
// 如果线程数量太小，线程组（32个线程）的内存延迟无法通过切换warp来隐藏延迟
// 此外，block中线程数量最好为32的整数倍，否则存在warp只有部分线程有效
int main() {

}
// 优化手法
// 线程组分歧：尽量保证一个warp的线程进同一个条件分支
// 延迟隐藏：block中有足够多的线程供SM调度，使SM陷入内存等待时调度其他warp
// 寄存器打翻：核函数用到许多局部变量，则每一个block线程数不宜太大
// 共享内存：全局内存低效，多次访问可以先读到共享内存
// 跨步访问：通过高带宽的共享内存承受跨步开销
// 区块冲突：同一个warp中多个线程访问共享内存中%32相等的地址会比较低效，可以将数组搞成不对齐的33跨步避免
